[{"categories":["个人笔记"],"content":"从Cooley-Tukey FFT到Stockham FFT 在阅读本文之前，你应当已理解了Cooley-Tukey FFT算法： 关于FFT运算的理解与入门，推荐观看该视频：快速傅里叶变换(FFT)——有史以来最巧妙的算法？ ； 关于FFT的进一步理解以及蝶形运算的理解，推荐阅读《算法导论》第20章； 关于库利-图基算法的进一步理解可参考网上各种博客。 关于Stockham FFT算法： 关于Stockham FFT的比较数学的介绍，推荐该文章：原地且自动整序的FFT算法 本文参考文档：OTFFT文档中的Stockham FFT介绍 库利-图基算法是经典的FFT算法，然而会导致得到的FFT序列顺序改变，因此需要位逆序的方法排布子FFT的顺序。Stockham FFT在变换的过程中调整顺序。这种变换不能通过原地操作实现，通过将计算的中间结果存储到另一片区域，下次变换的时候再存储回来，如此往复即为Stockham FFT算法（图片来自网络）： 下面参考OTFFT的介绍和代码，从Cooley-Tukey FFT开始，讨论如何一步步得到Stockham FFT。 ","date":"2023-03-02","objectID":"/stockhamfft/:0:0","tags":["个人笔记"],"title":"从Cooley-Tukey FFT到Stockham FFT","uri":"/stockhamfft/"},{"categories":["个人笔记"],"content":"1 Cooley-Tukey FFT算法及变形 原始Cooley-Tukey FFT算法代码如下所示： #include \u003ccomplex\u003e #include \u003ccmath\u003e #include \u003cutility\u003e typedef std::complex\u003cdouble\u003e complex_t; void butterfly(int n, int q, complex_t* x) // Butterfly operation // n : sequence length // q : block start point // x : input/output squence { const int m = n/2; const double theta0 = 2*M_PI/n; if (n \u003e 1) { for (int p = 0; p \u003c m; p++) { const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); const complex_t a = x[q + p + 0]; const complex_t b = x[q + p + m]; x[q + p + 0] = a + b; x[q + p + m] = (a - b) * wp; } butterfly(n/2, q + 0, x); butterfly(n/2, q + m, x); } } void bit_reverse(int n, complex_t* x) // Bitreversal operation // n : squence length // x : input/output sequence { for (int i = 0, j = 1; j \u003c n-1; j++) { for (int k = n \u003e\u003e 1; k \u003e (i ^= k); k \u003e\u003e= 1); if (i \u003c j) std::swap(x[i], x[j]); } } void fft(int n, complex_t* x) // Fourier transform // n : sequence length // x : input/output sequence { butterfly(n, 0, x); bit_reverse(n, x); for (int k = 0; k \u003c n; k++) x[k] /= n; } void ifft(int n, complex_t* x) // Inverse Fourier transform // n : sequence length // x : input/output sequence { for (int p = 0; p \u003c n; p++) x[p] = conj(x[p]); butterfly(n, 0, x); bit_reverse(n, x); for (int k = 0; k \u003c n; k++) x[k] = conj(x[k]); } 上述算法需要bit_reverse()重排顺序。Stockham FFT的目标是去掉重排序这一步。为了得到Stockham FFT算法，让我们先把Cooley-Tukey FFT改写成不需要调用独立的bit_reverse()函数的形式： #include \u003ccomplex\u003e #include \u003ccmath\u003e typedef std::complex\u003cdouble\u003e complex_t; void fft0(int n, int q, complex_t* x, complex_t* y) // n : sequence length // q : block start point // x : input/output sequence // y : work area { const int m = n/2; const double theta0 = 2*M_PI/n; if (n \u003e 1) { for (int p = 0; p \u003c m; p++) { // Butterfly operation const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); const complex_t a = x[q + p + 0]; const complex_t b = x[q + p + m]; y[q + p + 0] = a + b; y[q + p + m] = (a - b) * wp; } fft0(n/2, q + 0, y, x); fft0(n/2, q + m, y, x); for (int p = 0; p \u003c m; p++) { // Composition of even components and odd components x[q + 2*p + 0] = y[q + p + 0]; // Even components x[q + 2*p + 1] = y[q + p + m]; // Odd components } } } void fft(int n, complex_t* x) // Fourier transform // n : sequence length // x : input/output sequence { complex_t* y = new complex_t[n]; // Allocation of work arera fft0(n, 0, x, y); delete[] y; for (int k = 0; k \u003c n; k++) x[k] /= n; } void ifft(int n, complex_t* x) // Inverse Fourier transform // n : sequence length // x : input/output sequence { for (int p = 0; p \u003c n; p++) x[p] = conj(x[p]); complex_t* y = new complex_t[n]; // Allocation of work area fft0(n, 0, x, y); delete[] y; for (int k = 0; k \u003c n; k++) x[k] = conj(x[k]); } 这样改写过后，蝶形运算和重排序被合并到一个函数处理，fft()也被调整为入口函数fft()和fft0()。在fft0()中，通过x[], y[]两个数组来回存放，在完成蝶形运算后再把重排序的结果放到一个数组中去的办法实现了重排序。 这种做法可能比原始的Cooley-Tukey FFT更慢，但这是逐步得到Stockham FFT的第一步。 ","date":"2023-03-02","objectID":"/stockhamfft/:1:0","tags":["个人笔记"],"title":"从Cooley-Tukey FFT到Stockham FFT","uri":"/stockhamfft/"},{"categories":["个人笔记"],"content":"2 递归版本的Stockham FFT 分析上面的代码，可以发现有两个位置要对数组访问，一个是蝶形运算，另一个是奇数下标和偶数下标的重新组合。如果我们能同时执行这两个操作，那么多余的访存操作就可以被消除。通过这种改动，我们就得到了递归版本的Stockham FFT： #include \u003ccomplex\u003e #include \u003ccmath\u003e typedef std::complex\u003cdouble\u003e complex_t; void fft1(int n, int s, int q, complex_t* x, complex_t* y); void fft0(int n, int s, int q, complex_t* x, complex_t* y) // n : sequence length // s : stride // q : selection of even or odd // x : input/output sequence // y : work area { const int m = n/2; const double theta0 = 2*M_PI/n; if (n == 1) {} else { for (int p = 0; p \u003c m; p++) { // Butterfly operation and composition of even components and odd components const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); const complex_t a = x[q + s*(p + 0)]; const complex_t b = x[q + s*(p + m)]; y[q + s*(2*p + 0)] = a + b; y[q + s*(2*p + 1)] = (a - b) * wp; } fft1(n/2, 2*s, q + 0, y, x); // Even place FFT (y:input, x:output) fft1(n/2, 2*s, q + s, y, x); // Odd place FFT (y:input, x:output) } } void fft1(int n, int s, int q, complex_t* x, complex_t* y) // n : sequence length // s : stride // q : selection of even or odd // x : input sequence // y : output sequence { const int m = n/2; const double theta0 = 2*M_PI/n; if (n == 1) { y[q] = x[q]; } else { for (int p = 0; p \u003c m; p++) { // Butterfly Operation and composition of even components and odd components const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); const complex_t a = x[q + s*(p + 0)]; const complex_t b = x[q + s*(p + m)]; y[q + s*(2*p + 0)] = a + b; y[q + s*(2*p + 1)] = (a - b) * wp; } fft0(n/2, 2*s, q + 0, y, x); // Even place FFT (y:input/output, x:work area) fft0(n/2, 2*s, q + s, y, x); // Odd place FFT (y:input/output, x:work area) } } void fft(int n, complex_t* x) // Fourier transform // n : sequence length // x : input/output sequence { complex_t* y = new complex_t[n]; // Allocation of work area fft0(n, 1, 0, x, y); delete[] y; for (int k = 0; k \u003c n; k++) x[k] /= n; } void ifft(int n, complex_t* x) // Inverse Fourier transform // n : sequence length // x : input/output sequence { for (int p = 0; p \u003c n; p++) x[p] = conj(x[p]); complex_t* y = new complex_t[n]; // Allocation of work area fft0(n, 1, 0, x, y); delete[] y; for (int k = 0; k \u003c n; k++) x[k] = conj(x[k]); } 观察这段代码，有两个特点： 利用两块内存空间，在蝶形操作的时候将x[q + s*(p + 0)], x[q + s*(p + m)]的相互运算结果存放到y[q + s*(2*p + 0)], y[q + s*(2*p + 1)]中，从而合并了蝶形运算和重排序操作； 是互相调用的递归关系。关于这个代码设计，原文的解释是这样： “This code has become a mutual recursion in order to minimize the accesses to an array. Stockham algorithm requires work area y for sorting. It saves sorted results once in the work area. If the saved results are written back immediately to x, the program is able to avoid becoming a mutual recursion. But, if we do so, it becomes meaningless that we have reduced the accesses to an array by executing butterfly operation and composition at the same time. For this reason, this code has become a mutual recursion.” 百度翻译：为了最小化对数组的访问，这段代码变成了相互递归。Stockham算法需要工作区y进行排序。它将排序结果保存在工作区中一次。如果保存的结果立即写回x，则程序能够避免成为相互递归。但是，如果我们这样做，那么通过同时执行蝶形运算和组合来减少对数组的访问就变得毫无意义了。由于这个原因，这段代码变成了相互递归。 我暂时还没有搞懂。 从而，我们可以得到Stockham FFT的数学推导式，其中$n=2^{L-h},~m=2^{-1}n,~s=2^h,~x_h(q,p)=x_h[q+sp]$： $$ x_{h+1}(q,p)=x_h(q,p)+x_h(q,p+m) \\\\ x_{h+1}(q+s,p)=(x_h(q,p)-x_h(q,p+m))W_N^{sp} \\\\ q=0,1,…,s-1 \\\\ p=0,1,…,m-1 $$ $x_h[]$是第h步计算。当从$x_0[]$开始，得到$x_L[]$，FFT计算就完成了。 上述程序是基于频域抽取的FFT算法（DIF-FFT），基于时域抽取的FFT算法（DIT-FFT）如下所示： #include \u003ccomplex\u003e #include \u003ccmath\u003e typedef std::complex\u003cdouble\u003e complex_t; void fft1(int n, int s, int q, complex_t* x, complex_t* y); void fft0(int n, int s, int q, complex_t* x, complex_t* y) // n : sequence length // s : stride // q : selection of even or odd // x : input/output sequence // y : work area { const int m = n/2; const double theta0 = 2*M_PI/n; if (n == 1) {} else { fft1(n/2, 2*s, q + 0, y, x); // Even place FFT(x:input, y:output) fft1(n/2, 2*s, q + s, y, x); // Odd place FFT(x:input, y:output) for (int p = 0; p \u003c m; p++) { const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); const co","date":"2023-03-02","objectID":"/stockhamfft/:2:0","tags":["个人笔记"],"title":"从Cooley-Tukey FFT到Stockham FFT","uri":"/stockhamfft/"},{"categories":["个人笔记"],"content":"3 Stockham FFT的迭代优化 观察上个Stockham FFT的版本，变量q可改写为循环迭代的形式： #include \u003ccomplex\u003e #include \u003ccmath\u003e typedef std::complex\u003cdouble\u003e complex_t; void fft1(int n, int s, complex_t* x, complex_t* y); void fft0(int n, int s, complex_t* x, complex_t* y) // n : sequence length // s : stride // x : input/output sequence // y : work area { const int m = n/2; const double theta0 = 2*M_PI/n; if (n == 1) {} else { for (int q = 0; q \u003c s; q++) { // Iteration for recursive-call for (int p = 0; p \u003c m; p++) { const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); const complex_t a = x[q + s*(p + 0)]; const complex_t b = x[q + s*(p + m)]; y[q + s*(2*p + 0)] = a + b; y[q + s*(2*p + 1)] = (a - b) * wp; } } fft1(n/2, 2*s, y, x); // The number of recursive-calls is one because we tie calls with an iteration. } } void fft1(int n, int s, complex_t* x, complex_t* y) // n : sequence length // s : stride // x : input sequence // y : output sequence { const int m = n/2; const double theta0 = 2*M_PI/n; if (n == 1) { for (int q = 0; q \u003c s; q++) y[q] = x[q]; } else { for (int q = 0; q \u003c s; q++) { // Iteration for recursive-call for (int p = 0; p \u003c m; p++) { const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); const complex_t a = x[q + s*(p + 0)]; const complex_t b = x[q + s*(p + m)]; y[q + s*(2*p + 0)] = a + b; y[q + s*(2*p + 1)] = (a - b) * wp; } } fft0(n/2, 2*s, y, x); // The number of recursive-calls is one because we tie calls with an iteration. } } void fft(int n, complex_t* x) // Fourier transform // n : sequence length // x : input/output sequence { complex_t* y = new complex_t[n]; // Allocation of work area fft0(n, 1, x, y); delete[] y; for (int k = 0; k \u003c n; k++) x[k] /= n; } void ifft(int n, complex_t* x) // Inverse Fourier transform // n : sequence length // x : input/output sequence { for (int p = 0; p \u003c n; p++) x[p] = conj(x[p]); complex_t* y = new complex_t[n]; // Allocation of work area fft0(n, 1, x, y); delete[] y; for (int k = 0; k \u003c n; k++) x[k] = conj(x[k]); } 当递归的深度变深时，步长s会变大，导致访存操作的跳跃比较大，因此可以将p和q的循环对调： #include \u003ccomplex\u003e #include \u003ccmath\u003e typedef std::complex\u003cdouble\u003e complex_t; void fft1(int n, int s, complex_t* x, complex_t* y); void fft0(int n, int s, complex_t* x, complex_t* y) // n : sequence length // s : stride // x : input/output sequence // y : work area { const int m = n/2; const double theta0 = 2*M_PI/n; if (n == 1) {} else { for (int p = 0; p \u003c m; p++) { const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); for (int q = 0; q \u003c s; q++) { const complex_t a = x[q + s*(p + 0)]; const complex_t b = x[q + s*(p + m)]; y[q + s*(2*p + 0)] = a + b; y[q + s*(2*p + 1)] = (a - b) * wp; } } fft1(n/2, 2*s, y, x); } } void fft1(int n, int s, complex_t* x, complex_t* y) // n : sequence length // s : stride // x : input sequence // y : output sequence { const int m = n/2; const double theta0 = 2*M_PI/n; if (n == 1) { for (int q = 0; q \u003c s; q++) y[q] = x[q]; } else { for (int p = 0; p \u003c m; p++) { const complex_t wp = complex_t(cos(p*theta0), -sin(p*theta0)); for (int q = 0; q \u003c s; q++) { const complex_t a = x[q + s*(p + 0)]; const complex_t b = x[q + s*(p + m)]; y[q + s*(2*p + 0)] = a + b; y[q + s*(2*p + 1)] = (a - b) * wp; } } fft0(n/2, 2*s, y, x); } } void fft(int n, complex_t* x) // Fourier transform // n : sequence length // x : input/output sequence { complex_t* y = new complex_t[n]; fft0(n, 1, x, y); delete[] y; for (int k = 0; k \u003c n; k++) x[k] /= n; } void ifft(int n, complex_t* x) // Inverse Fourier transform // n : sequence length // x : input/output sequence { for (int p = 0; p \u003c n; p++) x[p] = conj(x[p]); complex_t* y = new complex_t[n]; fft0(n, 1, x, y); delete[] y; for (int k = 0; k \u003c n; k++) x[k] = conj(x[k]); } 最后，去除掉代码的重复部分： #include \u003ccomplex\u003e #include \u003ccmath\u003e typedef std::complex\u003cdouble\u003e complex_t; void fft0(int n, int s, bool eo, complex_t* x, complex_t* y) // n : sequence length // s : stride // eo : x is output if eo == 0, y is output if eo == 1 // x : input sequence(or output sequence if eo == 0) // y : work ","date":"2023-03-02","objectID":"/stockhamfft/:3:0","tags":["个人笔记"],"title":"从Cooley-Tukey FFT到Stockham FFT","uri":"/stockhamfft/"},{"categories":["个人笔记"],"content":"1 食谱问题（Diet Problem） 几种食物的每单位所含营养物质及其价格如下表所示，若每天需要2000千卡能量、55克蛋白质和800毫克钙，请问如何构造一个食物的组合，使得满足每天的营养物质需求且耗费金钱最少。 Oatmeal Whole milk Cherry pie Pork with beans 价格 3 9 20 19 能量 110 160 420 260 蛋白质 4 8 4 14 钙 2 285 22 80 解析： 线性规划问题的最基本形式。可设购买每种食物$x_1,x_2,x_3,x_4$单位，可得线性规划方程： $$ min\\; z=3x_1 + 9x_2 + 20x_3 + 19x_4 \\\\ \\begin{align*} s.t.\\; 110x_1 + 160x_2 + 420x_3 + 260x_4 \u0026≥ 2000 \\\\ 4x_1 + 8x_2 + 4x_3 + 14x_4 \u0026≥ 55 \\\\ 2x_1 + 285x_2 + 22x_3 + 80x_4 \u0026≥ 800 \\\\ x_1 , x_2 , x_3 , x_4 \u0026≥ 0 \\end{align*} $$ 上式可简写为： $$ min\\; z=c^Tx \\\\ \\begin{align*} s.t.\\; Ax\u0026=b \\\\ x\u0026\\geq 0 \\end{align*} $$ ","date":"2023-01-10","objectID":"/cs-lp/:1:0","tags":["个人笔记"],"title":"算法问题的线性规划建模","uri":"/cs-lp/"},{"categories":["个人笔记"],"content":"2 最大流问题（Maximum Flow Problem） 输入： 一个有向图$G\u003cV,E\u003e$，每条边$e=(u,v)$与容量$C(u,v)$相对应，源节点为$s$，目标节点为$t$。 输出： 求解每条边$e=(u,v)$对应的流量$0\\leq f(u,v)\\leq C(u,v)$，使到达目标节点的总流量$\\sum _{u,(s,u)\\in E}f(u,v)$最大。 解析： 对最大流问题进行线性规划建模，可将总流量最大设为线性规划的优化目标。线性规划的约束包括两部分： 进入某个节点的流量之和等于离开某个节点的流量之和； 每条边的流量不小于零且不大于最大容量。 可得线性规划方程： $$ max\\; z=\\sum _{v,(s,v)\\in E}f(s,v) \\\\ \\begin{align*} s.t.\\; \\sum _{u,(u,v)\\in E}f(u,v)-\\sum _{w,(v,w)\\in E}f(v,w)\u0026=0,\u0026v\\in V-s \\\\ f(u,v)\u0026\\geq 0,\u0026(u,v)\\in E \\\\ f(u,v)\u0026\\leq C(u,v),\u0026(u,v)\\in E \\end{align*} $$ ","date":"2023-01-10","objectID":"/cs-lp/:2:0","tags":["个人笔记"],"title":"算法问题的线性规划建模","uri":"/cs-lp/"},{"categories":["个人笔记"],"content":"3 最小费用流问题（Minimum Cost Flow Problem） 输入： 一个有向图$G\u003cV,E\u003e$，每条边$e=(u,v)$与容量$C(u,v)$、每单位流量花费$a(u,v)$相对应，流量总量为$d$，源节点为$s$，目标节点为$t$。 输出： 求解每条边$e=(u,v)$对应的流量$0\\leq f(u,v)\\leq C(u,v)$，使到达目标节点的总流量为$d$，且总花费$\\sum _{(u,v)\\in E}a(u,v)f(u,v)$最小。 解析： 对最小费用流问题进行线性规划建模，可将费用最小设为线性规划的优化目标。线性规划的约束包括三部分： 进入某个节点的流量之和等于离开某个节点的流量之和； 每条边的流量不小于零且不大于最大容量； 总流量为$d$。 可得线性规划方程： $$ min\\; z=\\sum _{(u,v)\\in E}a(u,v)f(u,v) \\\\ \\begin{align*} s.t.\\; \\sum _{u,(u,v)\\in E}f(u,v)-\\sum _{w,(v,w)\\in E}f(v,w)\u0026=0,\u0026v\\in V-s \\\\ f(u,v)\u0026\\geq 0,\u0026(u,v)\\in E \\\\ f(u,v)\u0026\\leq C(u,v),\u0026(u,v)\\in E \\\\ \\sum _{v,(s,v)\\in E}f(s,v)\u0026=d \\end{align*} $$ ","date":"2023-01-10","objectID":"/cs-lp/:3:0","tags":["个人笔记"],"title":"算法问题的线性规划建模","uri":"/cs-lp/"},{"categories":["个人笔记"],"content":"4 多物品流问题（Multi Commodity Flow Problem） 输入： 一个有向图$G\u003cV,E\u003e$，每条边$e=(u,v)$对应容量$C_e$。共有$k$个物品，对第$i$个物品，$s_i,t_i,d_i$分别表示其起点、终点和总量。 输出： 满足多物品流量约束、边容量约束的一个可行解。 解析： 由于只需要求一个可行解，因此优化目标可直接设为$max;z=0$。线性规划的约束包括三部分： 进入某个节点的各物品流量之和等于离开某个节点的各物品流量之和； 每条边的各物品流量不小于零且不大于最大容量； 对于物品$i$，总流量为$d_i$。 设每条边$e$流经的第$i$个物品的流量为$f_i(u,v)$，可得线性规划方程： $$ max\\; z=0 \\\\ \\begin{align*} s.t.\\; \\sum _{u,(u,v)\\in E}f_i(u,v)-\\sum {w,(v,w)\\in E}f_i(v,w)\u0026=0,\u0026v\\in V-s \\\\ f_i(u,v)\u0026\\geq 0,\u0026(u,v)\\in E \\\\ \\sum ^k{i=1}f_i(u,v)\u0026\\leq C(u,v),\u0026(u,v)\\in E \\\\ \\sum _{v,(s_i,v)\\in E}f(s_i,v)\u0026=d_i \\end{align*} $$ 线性规划是已知的该问题唯一多项式复杂度的解法。 ","date":"2023-01-10","objectID":"/cs-lp/:4:0","tags":["个人笔记"],"title":"算法问题的线性规划建模","uri":"/cs-lp/"},{"categories":["个人笔记"],"content":"5 SAT问题 SAT问题的介绍可参考此文章：SAT问题简介 概括而言，SAT问题的求解是为一个n元合取范式的变量进行真值指派，使得该式为真。 输入： 一个有m个子句的n元合取范式。 输出： 一组使该式为真的真值指派。 例题：$\\Phi=(x_1\\vee \\neg x_2 \\vee x_3)\\wedge (\\neg x_1\\vee x_2\\vee \\neg x_3)\\wedge (x_1\\vee x_2 \\vee \\neg x_3)$ 解析： 设线性规划的优化目标为最大化为真的子句数量，设指示第$j$个子句是否为真的变量为$c_j$，可得线性规划方程： $$ \\begin{align*} max\\;z=;\u0026 c_1 \u0026+\u0026c_2 \u0026+c_3 \u0026 \\\\ s.t.\\;\u0026 x_1 \u0026+\u0026(1-x_2) \u0026+x_3 \u0026\\geq c_1 \\\\ \u0026(1-x_1)\u0026+\u0026x_2 \u0026+(1-x_3)\u0026\\geq c_2 \\\\ \u0026x_1\u0026+\u0026x_2\u0026+(1-x_3)\u0026\\geq c_3 \\\\ \u0026x_1,\u0026\u0026x_2,\u0026x_3\u0026=0/1 \\\\ \u0026c_1,\u0026\u0026c_2,\u0026c_3\u0026=0/1 \\end{align*} $$ 上式中，约束的左侧表示为真的文字的数量，当至少存在一个为真时，该子句的真值便允许取值为1。当且仅当$z=3$时原问题有解。 ","date":"2023-01-10","objectID":"/cs-lp/:5:0","tags":["个人笔记"],"title":"算法问题的线性规划建模","uri":"/cs-lp/"},{"categories":["个人笔记"],"content":"一 绪论 ","date":"2021-06-28","objectID":"/osnote/:1:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"OS的作用 用户与硬件之间的接口 管理计算机资源 抽象计算机资源 ","date":"2021-06-28","objectID":"/osnote/:1:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"OS的发展 单道批处理系统 用户程序交给监控程序，由监控程序控制作业一个接一个交给IO处理 CPU等待IO、内存浪费、资源浪费 多道批处理系统 当一个作业在等待IO时，处理器可以切换到另一个不在等待IO的作业 中断：中断机构（硬件）发出信号，CPU转而处理中断程序工作，完成后再返回原来的工作 通道：专门负责输入输出的硬件，支持CPU和IO并行执行 作业的四种状态： 提交、后备、运行、完成 三级调度 低级调度：内存与内存 中级调度：内存与交换区 高级调度：外存到内存 多道程序设计好处 CPU利用率 内存和IO设备利用率 系统吞吐量 缺点 周转时间长 无交互能力 分时系统、实时系统、微机操作系统 操作系统的特征 并发、共享、异步、虚拟 概念区分：并发与并行、同步与异步 ","date":"2021-06-28","objectID":"/osnote/:1:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"二 OS结构 ","date":"2021-06-28","objectID":"/osnote/:2:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"陷阱和中断 中断：外部的被迫中断 陷阱：程序的主动中断 ","date":"2021-06-28","objectID":"/osnote/:2:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"双模式 计算机硬件通过模式位表示当前为内核模式或用户模式，区分操作系统执行的任务和用户执行的任务。可能引起损害的机器指令为特权指令，只有内核模式才可以执行特权指令。模式概念可以扩展为超过两个模式。 ","date":"2021-06-28","objectID":"/osnote/:2:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"系统调用 当要执行系统调用时，硬件通常将它作为软件中断。控制通过中断向量转到操作系统的中断服务程序，并且模式位也设为内核模式。内核首先验证参数是否正确和合法，执行请求，最后控制返回到系统调用之后的指令。 ","date":"2021-06-28","objectID":"/osnote/:2:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"定时器 为了防止用户程序陷入死循环，或者不调用系统服务且不将控制返回给操作系统，可以使用定时器，设置指定周期后中断计算机。 ","date":"2021-06-28","objectID":"/osnote/:2:4","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"三 进程与线程 ","date":"2021-06-28","objectID":"/osnote/:3:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"进程的定义 一个具有一定独立功能的可并发执行的程序，在一个数据集合上的运行过程 ","date":"2021-06-28","objectID":"/osnote/:3:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"进程与程序 运行的动态实体与静态实体 ","date":"2021-06-28","objectID":"/osnote/:3:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"进程的状态 新建状态、就绪状态、运行状态、阻塞状态、终止状态 ","date":"2021-06-28","objectID":"/osnote/:3:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"挂起 挂起/解挂的原因：用户、进程、系统的需要 增加挂起状态后：活动就绪、静止就绪、活动阻塞、静止阻塞 ","date":"2021-06-28","objectID":"/osnote/:3:4","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"PCB PCB是用以记录与进程相关信息的主存区，是进程存在的唯一标志 PCB的组织方式 线性方式、链接方式、索引方式 进程切换 P0-\u003e系统中断-\u003e[保存PCB0-\u003e…-\u003e加载PCB1]-\u003eP1-\u003e系统中断-\u003e[保存PCB1-\u003e…-\u003e加载PCB0]-\u003eP0 ","date":"2021-06-28","objectID":"/osnote/:3:5","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"进程创建与终止 进程图：用于描述进程家族关系的有向树，箭头表示创建关系 进程创建： 申请空白PCB 为新进程分配资源 初始化PCB 将新进程插入就绪队列 进程终止： 根据终止进程标识符，找到对应PCB 若该进程正在执行，终止进程，设置调度标志为真 如果该进程具有子孙进程，则终止其所有子孙 回收所有资源，归还给其父进程或系统 将PCB移出原所在队列 ","date":"2021-06-28","objectID":"/osnote/:3:6","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"进程通信 协作进程需要一种进程间通信机制（Interprocess Communicatio，IPC）来允许进程相互交互数据与信息 进程通信类型 共享存储器系统 消息传递系统 直接通信：Send(Receiver, msg), Receive(Sender, msg) 间接通信（信箱）：Send(mailbox, msg), Receive(mailbox, msg) 消息缓冲队列通信机制：生产者-消费者 管道通信 管道：用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称为Pipe文件 ","date":"2021-06-28","objectID":"/osnote/:3:7","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"线程 是进程中的一个实体，是能被系统独立调度和分派的基本单位 基本状态：就绪、执行、堵塞 基本操作：派生、调度、阻塞、激活、结束 ","date":"2021-06-28","objectID":"/osnote/:3:8","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"四 进程调度 三级调度模型 高级调度（作业调度）：后备队列-\u003e内存（长程调度） 低级调度（进程调度）：就绪队列-\u003e运行（短程调度） 中级调度（进程调度）：内存\u003c-\u003e交换区 调度算法 先来先服务（FCFS） 短作业优先（SJF） - 抢占式/非抢占式 优先级调度 - 抢占式/非抢占式 时间片轮转（RR） 多级队列 不同队列调度算法可以不同 队列之间有优先级差异或时间片分配 多级反馈队列 进程可在队列之间移动 参数： 队列数量 每个队列的调度算法 用以确定何时升级到更高优先级队列的方法 用以确定何时降级到更低优先级队列的方法 用以确定进程在需要服务时将会进入哪个队列的方法 ","date":"2021-06-28","objectID":"/osnote/:4:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"五 进程同步 ","date":"2021-06-28","objectID":"/osnote/:5:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"Peterson算法 两个进程互相谦让 while (true) { flag[i] = TRUE; turn = j; while ( flag[j] \u0026\u0026 turn == j); CRITICAL SECTION flag[i] = FALSE; REMAINDER SECTION } ","date":"2021-06-28","objectID":"/osnote/:5:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"信号量机制 semaphore mutex=1; process_1（）{ while(true) { wait(mutex); critical section; signal(mutex); remainder section; } } ","date":"2021-06-28","objectID":"/osnote/:5:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"生产者-消费者 Semaphore muter=1, empty=N, full=0; Producer() { while (true) { produce item v; wait(empty); wait(mutex); b[in] = v; in = (in+1)%N; signal(mutex); signal(full); } } Comsumer() { while (true) { wait(full); wait(mutex); w = b[out]; out = (out+1)%N; signal(mutex); signal(empty); consume item w; } } ","date":"2021-06-28","objectID":"/osnote/:5:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"读者-写者问题 Semaphore mutex=1, db=1; int readercount=0; Reader() { while (true) { wait(mutex); readcount++; if (readcount == 1) { wait(db); } signal(mutex); Reading; wait(mutex); readcount--; if (readcount == 0) { signal(db); } signal(mutex); } } Writer() { while (true) { wait(db); writing; signal(db); } } ","date":"2021-06-28","objectID":"/osnote/:5:4","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"管程 条件变量：condition x, y; 每个条件变量都关联了一个队列，包含因该条件而阻塞的进程，对条件变量仅有的操作是wait()、signal() x.wait()： 将自己阻塞在等待队列中 唤醒一个等待者或者释放管程的互斥访问 x.signal()： 将等待队列中的一个线程唤醒 如果等待队列为空，则等同空操作 ","date":"2021-06-28","objectID":"/osnote/:5:5","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"哲学家就餐问题（管程） monitor DP { enum { THINKING, HUNGRY, EATING} state [5] ; condition self [5]; void pickup (int i) { state[i] = HUNGRY; test(i); if (state[i] != EATING) self [i].wait; } void putdown (int i) { state[i] = THINKING; // testing left and right neighbors test((i + 4) % 5); test((i + 1) % 5); } void test (int i) { if ( (state[(i + 4) % 5] != EATING) \u0026\u0026 (state[i] == HUNGRY) \u0026\u0026 (state[(i + 1) % 5] != EATING) ) { state[i] = EATING ; self[i].signal () ; } } initialization_code() { for (int i = 0; i \u003c 5; i++) state[i] = THINKING; } } ","date":"2021-06-28","objectID":"/osnote/:5:6","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"六 死锁 多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程将永远无法推进 ","date":"2021-06-28","objectID":"/osnote/:6:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"死锁发生的必要条件 互斥 非抢占 占有并等待 循环等待 ","date":"2021-06-28","objectID":"/osnote/:6:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"资源分配图 无环一定不死锁 单资源有环一定死锁 ","date":"2021-06-28","objectID":"/osnote/:6:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"死锁的处理方法 死锁预防 破坏占有并等待 方法一：必须获得全部资源才能运行 方法二：申请资源前必须释放自己已占有所有资源 破坏非抢占 方法一：进程申请某资源，有则分配，无则释放该进程所有资源并等待 方法二：进程申请某资源，有则分配，否则检测有该资源的另一进程，若该进程在等待则抢占，否则申请资源的进程等待（允许被抢占资源） 破坏循环等待 给资源编号 进程只能按递增顺序申请资源 如果需要同一资源多个实例需一次申请 申请编号更小资源时，需先将大编号资源全部释放 破坏互斥 临界资源不可能做到 死锁避免 系统的安全状态：Max, Allocation, Available 若存在一分配顺序使进程全部执行的安全序列，则认为是安全状态 银行家算法：Max, Allocation, Need, Available 死锁检测 单实例：分配图 多实例：银行家 死锁恢复 进程终止 终止全部死锁进程 一次终止一个 资源抢占 选择一个牺牲品使代价最小 回滚：将进程回滚到某安全状态 饥饿：防止进程饥饿，需要有限牺牲某进程 ","date":"2021-06-28","objectID":"/osnote/:6:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"七 存储管理 ","date":"2021-06-28","objectID":"/osnote/:7:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"相关概念和术语 逻辑地址（logical address）/相对地址：CPU所生成的地址，又称为虚拟地址（virtual address） 物理地址（physical address）/绝对地址：内存单元所看到的地址（加载到内存地址寄存器中的地址） 逻辑地址空间（logical address space）：由程序所生成的所有逻辑地址的集合称为逻辑地址空间 物理地址空间（physicaladdress space ）：与逻辑地址对应的所有物理地址的集合称为物理地址空间 重定位（relocation）：从逻辑地址（虚拟地址）到物理地址的映射称为重定位，由内存管理单元（MMU）完成 重定位寄存器：基址寄存器、限长寄存器 绑定：从一个地址空间到另一个地址空间的映射 ","date":"2021-06-28","objectID":"/osnote/:7:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"内存保护 基地址寄存器：最小的合法的物理内存地址 界限地址寄存器：指定范围的大小 内存空间保护的实现通过CPU硬件对在用户模式下产生的地址与寄存器的地址进行比较来完成 ","date":"2021-06-28","objectID":"/osnote/:7:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"用户程序处理过程 重定位 静态重定位：程序装入主存之前由编译/链接程序完成重定位，入主存可立即执行 动态重定位：程序入主存之前不进行重定位，入主后存执行到与地址相关项时，再进行重定位 装入方式 绝对装入：程序在编译时完成静态重定位，按绝对地址装入内存 可重定位装入：根据内存使用情况，将装入模块进行静态重定位后装入内存 动态运行时装入：装入程序将装入模块装入内存后，不将装入模块的逻辑地址转换为物理地址，在执行时用重定位寄存器进行动态重定位 链接方式 静态链接：程序运行之前，先将各目标模块以及所需库函数链接成一个完整的装入模块 装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式 容易共享：每个库程序的引用都有一个存根，用于指出如何定位适当的内存驻留库程序 运行时动态链接：将对某些目标模块的链接推迟到程序执行时才进行 ","date":"2021-06-28","objectID":"/osnote/:7:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"连续分配存储管理 单一连续分配 固定分区分配 内碎片 动态分区分配/可变分区分配 算法： 首次适应 循环首次适应 最佳适应 最差适应 ","date":"2021-06-28","objectID":"/osnote/:7:4","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"碎片 外碎片：内存中小块的空闲分区，无法单独满足任何一个进程的需求 内碎片：固定分区分配方式中存在的，已经分配给进程，但进程不会使用的空闲空间 紧缩、离散分配内存 ","date":"2021-06-28","objectID":"/osnote/:7:5","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"覆盖与交换技术 覆盖：进程内部区域的替换，主要用于早期操作系统 把程序划分为若干功能上相对独立的程序段，按照自身逻辑结构将那些不会同时执行的程序段共享同一块内存区域 程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段 交换：进程之间的替换 当内存空间紧张时，系统将内存中某些进程暂时移到外存（盘交换区），把外存中某些进程换入内存中，替换移出进程原来的内存空间 这种技术是进程在内存与外存之间的动态调度，多用于分时系统中 中级调度：采用交换技术 ","date":"2021-06-28","objectID":"/osnote/:7:6","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"分页存储管理 分页（长度固定） 分页思想 内存物理地址空间按2n等分成页框/帧（frame），并从0连续编号：0,1,2,… 作业的逻辑地址空间按页框/帧大小等分成页，并从0连续编号：0,1,2,… 作业逻辑地址表示为：v=(p,d) 作业连续的页，可以分配不连续的页框/帧 系统设置页表PMT保存作业各页入内存后的情况，包含页号、页框号 设置一个页表地址寄存器，保存当前执行进程页表的起始地址和页表的长度 分段（长度可变） 段页式（分段管理虚存，分页管理实存） ","date":"2021-06-28","objectID":"/osnote/:7:7","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"地址变换 直接地址变换 借助页表、页表寄存器完成作业的逻辑地址（虚地址）到内存物理地址的变换 页表基址寄存器（Page-table base register，PTBR）页表长度寄存器（Page-table length register，PRLR） 具有快表的地址变换 增设若干具有并行查询能力的特殊高速缓冲寄存器（联想寄存器/快表），保存当前执行进程的部分页表 程序的局部性特征 ","date":"2021-06-28","objectID":"/osnote/:7:8","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"页表 页表是一种特殊的数据结构，放在系统空间的页表区，存放逻辑页与物理页帧的对应关系。 每一个进程都拥有一个自己的页表，PCB表中有指针指向页表 层次页表 哈希页表 反置页表 一般页表：每个进程都有一个相关的页表，这些页表可能消耗大量的物理内存 反置页表：为每一个物理页框设置一个条目，并记录该物理页框所分配的进程ID和对应的逻辑页 ","date":"2021-06-28","objectID":"/osnote/:7:9","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"八 虚存管理 ","date":"2021-06-28","objectID":"/osnote/:8:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"请求分页机制 在分页系统的基础上增加了请求调页功能和页面置换功能 整个用户程序驻留在磁盘（二级存储）上，只装入少量页面入内存即可启动运行 程序运行中，由调页程序（pager）根据需要将单个页面 从磁盘调入内存， 将不需要的页面换出到磁盘上 置换时以页为单位 硬件支持 请求页表机制 缺页中断机构 地址变换机构 请求页表机制 状态位P（有效-无效位）：用于指示该页是否已经调入内存 访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，以供置换算法在选择置换页面时参考 修改位M（脏位）：标识该页在调入内存后是否被修改过 外存地址：该页在外存上的地址，一般指物理块号 缺页中断机构处理过程 访问进程页表，查看访问页是否合法 如果是非法访问，则终止进程访问；如果页面访 问合法，但该页不在内存中，则需要调入 在物理内存中找到一个空闲页框（free frame） 调度磁盘操作，将失效页从备用存储（磁盘）中 装入空闲页框 重置页表，修改页面信息 重启因缺页而中断的指令 地址变换机构（有快表） 存储保护检查：页号\u003e页表长度？ 是，越界中断 否则2 查快表 找到，修改访问位对于写操作置修改位，形成物理地址访问 若未找到，查页表状态位 在主存，将表目写入快表 否则，缺页中断 ","date":"2021-06-28","objectID":"/osnote/:8:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"页面置换算法 基本页面置换流程 查找所需页在磁盘上的位置 查找一个空闲的页框： 如果有空闲页框，那么就使用它 如果有没有空闲页框，就使用页面置换算法以选 择一个“牺牲”页框（victim frame） 将“牺牲”页框的内容写到磁盘上，修改页表和 页框表 将所需页读入空闲页框，修改相应的页表和页 框表 重启用户进程 页面置换算法详解 评价指标：缺页率 先进先出（FIFO）页面置换算法 最佳（Optimal）置换算法（理论上） 置换未来最长时间内不会访问的页面 最近最少使用（LRU）页面置换算法 近似LRU页面置换算法 附加访问位算法 为页表中的每一页保留一个8位的字节 在规定的时间间隔（如每隔100ms）内，时钟定时器产生中断，OS将页面的访问位转移到8位字节的高位，其他位均向右移一位，最低位丢弃，这个8位字节记录了该页面在最近的8个时间间隔内的使用情况 选择值最小的页面置换，相等情况下按照FIFO算法执行 二次机会算法（Clock置换算法） 页表中的每一页有一个访问位（页面被访问后将其置为1） 按照FIFO的方式选择置换页，如果该页的访问位为1，则给予第二次机会，将其访问位置为0 最不经常使用（Least Frequently Used，LFU）页面置换算法 最常使用（Most Frequently Used，MFU）页面置换算法 具有最小次数的页可能刚刚调入内存 ","date":"2021-06-28","objectID":"/osnote/:8:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"页框分配算法 固定分配算法 平均分配 按比例分配：进程大小 基于优先级分配算法 按照进程的优先级成比例给进程分配页框 进程发生缺页中断时 选择自己的页框进行页面置换 选择优先级更低的进程的页框置换 全局分配与局部分配 全局置换：允许从所有页框中置换 局部置换：仅仅从分配给进程自己的页框中进行置换 ","date":"2021-06-28","objectID":"/osnote/:8:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"请求分页系统的性能分析 抖动（thrashing） CPU的利用率会随着道数的增加而提高，直到达到最大值 达到最大值后继续提高道数，CPU的利用率将不再提高，反而急剧下降，这就是“系统抖动” 为了提升CPU利用率，则需要减少道数，消除抖动 抖动产生的原因 同时在系统中运行的进程太多，分配给每个进程的页框太少，不能满足进程正常运行的基本要求 工作集：进程在某段时间内实际访问页的集合 $WS(t,\\Delta)$，$\\Delta$为工作集尺寸 $D=sum(WS_n(…))$，$m$为页框数，若$D\u003em$，则挂起进程 预防抖动 采取局部置换策略 将工作集算法融入作业调度 利用“L=S”准则调节缺页率 选择暂停的进程 ","date":"2021-06-28","objectID":"/osnote/:8:4","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"九 I/O系统 ","date":"2021-06-28","objectID":"/osnote/:9:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"I/O系统的基本功能 隐藏物理设备的细节 与设备的无关性 提高处理机和I/O设备的利用率 对I/O设备进行控制 确保对设备的正确共享 错误处理 ","date":"2021-06-28","objectID":"/osnote/:9:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"I/O系统的层次结构 用户层软件 设备独立性软件 设备驱动程序 中断驱动程序 硬件 ","date":"2021-06-28","objectID":"/osnote/:9:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"I/O系统接口 块设备接口 流设备接口 网络通信接口 ","date":"2021-06-28","objectID":"/osnote/:9:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"I/O系统结构 总线型结构 通道型结构 ","date":"2021-06-28","objectID":"/osnote/:9:4","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"I/O控制方式 程序直接控制方式 CPU轮询I/O设备 程序直接控制I/O方式中CPU直接控制I/O操作的过程 CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中 中断驱动I/O控制方式 I/O控制器：一旦接受到CPU读命令，则开始读数据；完成读数据后发送中断信号表示已就绪，当CPU请求数据时传输数据，等待下一次I/O操作 CPU：CPU发出读信号以后继续其他工作，每个指令周期末尾检测中断信号，若检测到，则转向执行中断处理程序 DMA控制方式 数据传输的基本单位是数据块 所传送的数据是从设备直接送入内存的，或者相反 仅在传送一个或多个数据块的开始和结束时，才需CPU干预 通道控制方式 I/O通道控制方式是一种以内存为中心，实现外设与内存直接交换数据的控制方式 与DMA方式相比，通道所需要CPU干预更少， 每次可以完成多个不连续的数据块传送，而且可以做到一个通道控制多台设备，从而进一步减轻了CPU的工作 I/O通道具有自己的指令系统，并能实现指令所控制的操作，由CPU发出启动指令启动 通过执行通道程序并与设备控制器共同实现对I/O设备的控制 ","date":"2021-06-28","objectID":"/osnote/:9:5","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"缓冲 引入原因 缓和CPU与I/O设备间速度不匹配的矛盾 提高CPU和I/O设备之间的并行性 减少CPU对I/O的干预，减少对CPU的中断频率， 放宽对CPU中断响应时间的限制 缓冲实现机制 单缓冲区 双缓冲区 环缓冲区 缓冲池 对多个缓冲区的管理 收容输入、提取输入、收容输出、提取输出 设备独立性 逻辑设备与物理设备无关 SPOOLING（假脱机系统） 组成 输入井/输出井 输入缓冲区/输出缓冲区 输入进程/输出进程 当用户进程请求打印时， SPOOLing打印机系统为它做两件事： 在输出井中为之申请一个空闲磁盘分区， 并将要打印的数据送入其中 再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中， 再将该表挂到打印请求队列上 打印机空闲时：输出进程取出一张打印请求表，再从输出井中取出打印数据到输出缓冲区，通过打印机进行打印 ","date":"2021-06-28","objectID":"/osnote/:9:6","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"十 文件系统 ","date":"2021-06-28","objectID":"/osnote/:10:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"文件的逻辑结构 有结构文件（记录式文件） 顺序文件 索引文件 索引顺序文件 直接文件/哈希文件 无结构文件（流式文件） ","date":"2021-06-28","objectID":"/osnote/:10:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"文件的目录结构 单级目录结构 两级目录结构：系统目录+用户目录 树形目录结构：在两级目录的基础上，允许用户自行添加子目录 无环图目录结构：同一文件和子目录可出现在不同目录中 别名问题、悬挂指针问题 通用目录结构：允许存在环 ","date":"2021-06-28","objectID":"/osnote/:10:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"文件共享 基于索引节点的共享方式 设置索引节点，存储文件的物理地址、链接计数（共享计数）及其它文件属性 文件目录只包括文件名和该文件对应索引节点的指针 利用符号链实现文件共享 假设B为了共享C的文件F，在B中创建一个Link类型的新文件，新文件目录中只包含被链接文件F的路径名，称这种链接方法为符号链接（symbolic Linking） 说明：只有文件主人的目录中有文件索引节点的指针，其它用户目录中只有路径名 ","date":"2021-06-28","objectID":"/osnote/:10:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"文件保护措施：存取控制 访问矩阵 ","date":"2021-06-28","objectID":"/osnote/:10:4","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"文件的物理结构 连续文件 链接文件 索引文件 ","date":"2021-06-28","objectID":"/osnote/:10:5","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"空闲空间管理 空闲表法 位向量 空闲块链 ","date":"2021-06-28","objectID":"/osnote/:10:6","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"十一 磁盘管理 ","date":"2021-06-28","objectID":"/osnote/:11:0","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"磁盘的访问时间 数据传输时间、平均旋转延迟时间、寻道时间 ","date":"2021-06-28","objectID":"/osnote/:11:1","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"磁盘调度算法 先来先服务（FCFS） 最短寻道优先（SSTF） 扫描算法（SCAN、电梯算法） 循环扫描（C-SCAN） LOOK/C-LOOK（不扫描到终点，到最远的进程就马上掉头） FSCAN：在扫描的过程中所有新产生的序列放在另外的一个队列中，当访问完当前队列之后，再访问新产生的一个队列；队列按SCAN算法处理 ","date":"2021-06-28","objectID":"/osnote/:11:2","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"廉价磁盘冗余阵列RAID 并行交叉存取： 有多台磁盘驱动器，系统将每一盘块中的数据分为若干个子盘块数据，再把每一个子盘块的数据分别存储到各个不同磁盘 中的相同位置上 当要将一个盘块的数据传送到内存时，采取并行传输方式，从而减少传输时间 ","date":"2021-06-28","objectID":"/osnote/:11:3","tags":["个人笔记"],"title":"操作系统复习笔记","uri":"/osnote/"},{"categories":["个人笔记"],"content":"1 编译与预编译版本选择 如果对LLVM没有特别需求，只是当作一般编译器使用，安装预编译版也足以应付场面；如果需要对LLVM作个性化定制，或基于LLVM开发，或学习LLVM源码，那手动编译LLVM工程会是更好的选择。 2 操作系统选择 此处选择Linux系统。 3 编译安装指南 LLVM是一个仍在快速发展的开源项目，已经成为又一个版本怪物，中文互联网上鱼龙混杂的各种LLVM编译步骤指南大多已经过时，或隐藏着各种未知的坑，即使是官方不同出处的文档，也可能存在各自不规整统一之处。 因此，LLVM编译指南靠谱程度依次为：GitHub仓库的Readme.md$\u003e$官方各种文档$\u003e$互联网其他编译指南。而我的建议是—— 直接从GitHub仓库克隆工程到本地进行编译！ 直接从GitHub仓库克隆工程到本地进行编译！ 直接从GitHub仓库克隆工程到本地进行编译！ 为什么直接从GitHub仓库clone？一方面，它足够完整，便于利用cmake指令灵活定制并集中编译；另一方面，GitHub上的Readme.md提供的安装指南一定是紧跟版本的，无过时之虞。如果不需要GitHub上LLVM的最新版本，只需要在把工程clone到本地以后再手动回退到指定tag的版本即可。 GitHub回退到指定版本（指定Tag）的网上教程很多，此处不再赘述。注意我们只需要硬回退本地版本，不需要回退以后提交到远程仓库的步骤。 综上所述，无痛编译安装LLVM的步骤和方法是：从GitHub仓库克隆工程到本地，将本地工程回退到指定版本，再按照对应版本的readme.md教程编译LLVM工程。 4 Linux下编译指定版本LLVM实例 编译平台：Ubuntu 20.04.2 LTS LLVM版本：10.0.1 LLVM的GitHub仓库链接：https://github.com/llvm/llvm-project 注：编译过程中需要的git, cmake等组件从略，请根据官方指示或编译中的实际踩坑安装所需依赖。 ","date":"2021-02-26","objectID":"/llvmsetup/:0:0","tags":["个人笔记"],"title":"Linux系统无痛编译安装LLVM简明指南","uri":"/llvmsetup/"},{"categories":["个人笔记"],"content":"4.1 仓库下载 国内下载GitHub仓库往往有速度太慢的问题，互联网对此有相当多的解决方案。此处采用的是CSDN博客https://blog.csdn.net/haejwcalcv/article/details/108028245 中提到的办法，具体地说，只需把github.com换成github.com.cnpmjs.org即可。 克隆仓库命令如下： git clone https://github.com.cnpmjs.org/llvm/llvm-project.git 注意，如果是在win平台下克隆仓库，还应当禁止代码换行符的自动转换，加上--config core.autocrlf=false： git clone --config core.autocrlf=false https://github.com.cnpmjs.org/llvm/llvm-project.git ","date":"2021-02-26","objectID":"/llvmsetup/:1:0","tags":["个人笔记"],"title":"Linux系统无痛编译安装LLVM简明指南","uri":"/llvmsetup/"},{"categories":["个人笔记"],"content":"4.2 回退版本 因为GitHub仓库维护的是最新版本，因此我们需要用git将版本回退到指定tag。首先，我们需要先查询llvm的tag列表： git tag 控制台输出如下： llvmorg-1.0.0 llvmorg-1.1.0 llvmorg-1.2.0 llvmorg-1.3.0 llvmorg-1.4.0 llvmorg-1.5.0 llvmorg-1.6.0 llvmorg-1.9.0 llvmorg-10-init llvmorg-10.0.0 llvmorg-10.0.0-rc1 llvmorg-10.0.0-rc2 llvmorg-10.0.0-rc3 llvmorg-10.0.0-rc4 llvmorg-10.0.0-rc5 llvmorg-10.0.0-rc6 llvmorg-10.0.1 llvmorg-10.0.1-rc1 llvmorg-10.0.1-rc2 llvmorg-10.0.1-rc3 llvmorg-10.0.1-rc4 llvmorg-11-init llvmorg-11.0.0 : 查看控制台输出可得，llvm 10.0.1对应的tag版本是llvmorg-10.0.1。查询该tag版本的信息指令如下： git show llvmorg-10.0.1 控制台输出如下： tag llvmorg-10.0.1 Tagger: Tom Stellard \u003ctstellar@redhat.com\u003e Date: Mon Jul 20 16:55:03 2020 -0700 Tag 10.0.1 commit ef32c611aa214dea855364efd7ba451ec5ec3f74 (HEAD -\u003e main, tag: llvmorg-10.0.1-rc4, tag: llvmorg-10.0.1, origin/release/10.x) Author: Hubert Tong \u003chubert.reinterpretcast@gmail.com\u003e Date: Thu Apr 30 22:18:54 2020 -0400 [tests] Revert unhelpful change from d73eed42d1dc (cherry picked from commit 0e8608b3c38886c224d252c6b126c804645b7761) diff --git a/llvm/test/CodeGen/X86/asm-modifier.ll b/llvm/test/CodeGen/X86/asm-modifier.ll index 0b8b240f7f7d..47b185a15766 100644 --- a/llvm/test/CodeGen/X86/asm-modifier.ll +++ b/llvm/test/CodeGen/X86/asm-modifier.ll @@ -1,4 +1,4 @@ -; RUN: llc \u003c %s -mtriple=x86_64-unknown-unknown | FileCheck %s +; RUN: llc \u003c %s | FileCheck %s : 由输出的内容可得，tag llvmorg-10.0.1对应的commit编号是ef32c611aa214dea855364efd7ba451ec5ec3f74，使用reset指令回退版本到该处： git reset --hard ef32c611aa214dea855364efd7ba451ec5ec3f74 版本回退成功后，输入git show可以看到，git仓库的head指针已经回退到了llvm 10.0.1版本。 ","date":"2021-02-26","objectID":"/llvmsetup/:2:0","tags":["个人笔记"],"title":"Linux系统无痛编译安装LLVM简明指南","uri":"/llvmsetup/"},{"categories":["个人笔记"],"content":"4.3 编译llvm工程 选择github仓库上的release/10.x分支，查阅对应的Readme.md，并根据Readme的指示进行安装。 首先，建立并切换到对应的build目录： cd llvm-project mkdir build cd build 然后，根据编译需求，输入cmake指令build工程。此处选择Ninja方式建立文件，额外编译clang, clang-tool-extra, compiler-rt项目。 cmake -G \"Ninja\" -DLLVM_ENABLE_PROJECTS=\"clang;clang-tools-extra;compiler-rt;\" ../llvm 在build的过程中，可能会出现一些Not found的提示信息，只要没有报错，就可以正常进行。 命令执行完以后，可以立刻输入echo $?命令查看上一条命令的执行情况，如果返回值为0，则说明build命令执行成功。 因为选择了Ninja方式build文件，此处采用ninja的命令完成工程构建： ninja \u0026\u0026 ninja install 同理，命令执行完以后，立刻输入echo $?命令查看上一条命令的执行情况，如果返回值为0，则说明build命令执行成功。 输入指令clang -v验证是否安装成功，返回如下信息： clang version 10.0.1 (https://github.com.cnpmjs.org/llvm/llvm-project.git ef32c611aa214dea855364efd7ba451ec5ec3f74) Target: x86_64-unknown-linux-gnu Thread model: posix InstalledDir: /usr/local/bin Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/9 Selected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/9 Candidate multilib: .;@m64 Selected multilib: .;@m64 可见已成功安装llvm+clang 10.0.1版本。 20210518更新：如安装过程中gg，有可能是交换空间不足，需要手动挂载swap，可以搜索引擎查找相关教程，本文不再列出；如果是其他错误，按错误提示按部就班解决即可。 ","date":"2021-02-26","objectID":"/llvmsetup/:3:0","tags":["个人笔记"],"title":"Linux系统无痛编译安装LLVM简明指南","uri":"/llvmsetup/"},{"categories":["个人笔记"],"content":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法 语法分析有两个总的思路，一个是自顶向下分析，一个是自底向上分析。自底向上的分析思路是，对一个句子$s$，不断进行归约（“合并”），看能否归约成开始符号$S$的状态。 ","date":"2021-01-27","objectID":"/compilerlr/:0:0","tags":["个人笔记"],"title":"【编译原理】简明自底向上分析算法总结：LR(0)，SLR，LR(1)，LALR分析算法","uri":"/compilerlr/"},{"categories":["个人笔记"],"content":"自底向上分析（LR概述） 自底向上分析通常讨论的是LR分析算法，也叫“移进-归约算法”。仍然是循序渐进的讨论，从比较朴素的归约动机开始，逐步讨论如何对其完善。 LR分析指每次从左(L)读入，从右(R)反向构造出最右推导序列。分析是在从左到右读入的过程中进行的。在读入一定子串以后，如果右端可以进行归约，则向上归约。引入点记号“·”以指示句子读入的情况。如下例子所示： 有文法如下： E -\u003e E + T | T T -\u003e T * F | F F -\u003e n 给出算式 2 + 3 * 4，归约过程如下： 2 + 3 * 4 2 · + 3 * 4 F · + 3 * 4 T · + 3 * 4 E · + 3 * 4 E + · 3 * 4 E + 3 · * 4 E + F · * 4 E + T · * 4 E + T * · 4 E + T * 4 · E + T * F · E + T · E · S · 由此，LR过程实际上生成的是一个逆序的最右推导。已处理部分的符号串，实际上是一个栈结构。因此，该算法的框架可以归纳成如下的移进、归约两个步骤。 移进：将一个记号移进到栈顶中； 归约：将栈顶的n个符号归约成一个非终结符。 显然，我们需要一个机制去确定何时应当移进，何时应当归约，否则该算法也会退化成盲目的搜索。 讨论“句柄”的概念。句柄在LR算法中可以理解为和产生式右部匹配的子串。显然，找到合适的句柄，我们就能在正确的步骤归约，从而实现对句子$s$的正确验证。 为了正确高效地实现LR算法，我们可以采取类似于LL的**表驱动的算法思路。**通常来说，LR类算法的分析表结构如下： 状态 ACTION GOTO …（非终结符分栏） …（终结符分栏） $ACTION$，即“动作”。在第$n$个状态时读入某终结符应当做什么动作。$ACTION$表的元素通常有2种： $si$，s是“shift”的缩写，指示状态的转换，i指示转换到的状态编号； $ri$，r是“reduce”的缩写，指示此时应当对栈顶子串做归约动作，i指示对应的（右部）表达式的编号。 此外，$ACTION$表中的“acc”是“accept”的缩写，表示读入到此处的时候可以已可以接受该句子，LR算法结束。 $GOTO$表意思是“跳转”，表示归约在栈顶得到某非终结符后，应该跳转到什么状态。 不同的LR算法，对分析表的构造方法并不相同。以下将对LR(0)，SLR，LR(1)，LALR进行讨论。 ","date":"2021-01-27","objectID":"/compilerlr/:1:0","tags":["个人笔记"],"title":"【编译原理】简明自底向上分析算法总结：LR(0)，SLR，LR(1)，LALR分析算法","uri":"/compilerlr/"},{"categories":["个人笔记"],"content":"LR(0)分析 首先，为求解方便，我们可以将文法$G$转换为增广文法$G’$，即对开始符号$S$增加一条$S’\\rightarrow S$，$S’$是新的开始符号，求解从$S’$开始。具体而言，这样做是为了开始符号只在位于一条式子的左部。 为讨论方便，补充项目的定义：项目即规约过程中的一个带点的句子，是左边规约部分和右边未读入部分的拼接。 那么，刚刚在讨论分析表时，表的每一横行代表某状态。所以，该如何划分状态呢？我们可以讨论一种“等价”。比如有式子 $ S\\rightarrow E+E,E\\rightarrow aBc $，当前的项目状态是$S\\rightarrow E+·E$。那么，我“期盼”着将要读入的是$E$，也就等价于我“期盼着”将要读入的是$aBc$。我们将这些等价的项目归为同一个集，称为项目集闭包，对应自动机中的一个状态。 由此，我们可以得到求项目集闭包的通俗描述：若”期盼着“读入某符号，将其归入一个状态；若该符号是非终结符，那么对于它的某右部表达式，也就相当于”期盼“着读入该表达式的第一个符号，那么该符号的相关项目也应当归入该状态。 根据构造闭包的思路，我们有LR(0)分析表构造算法如下： 首先，根据$S’\\rightarrow S$构造初始闭包C0，该闭包只含一个项目：$S’\\rightarrow ·S$ 若闭包的分析还没有完成，取出某还没有分析的闭包，根据它读入新符号以后的action和goto情况，建立新的状态闭包 LR(0)分析表构造算法伪代码如下： closure(C) // C是某状态对应的闭包 while (C is still changing) for (item i: C) // example: i = A-\u003e beta · B gamma C += {B -\u003e ...} Goto(C, x) // 求GOTO得到的新状态 tmp = {} for (item i: C) // example: i = A-\u003e beta · B gamma tmp += {A-\u003e beta B · gamma} return closure(C) LR0_table() C0 = closure(S'-\u003e·S$) state_set = {C0} Q = enqueue(C0) while (Q isn't empty) C = dequeue(Q) for (x: N+T) // N是非终结符集，T是终结符集 D = Goto(C, x) if (x in T) ACTION[C][x] = D else GOTO[C][x] = D if (D isn't in state_set) state_set.add(D) enqueue(D) LR(0)算法伪代码如下： stack = [] push($) // 终止符 push(1) // 初始状态 while (true) token t = nextToken() state s = stack[top] if (ACTION[s][t] == \"si\") push(t) push(i) else if (ACTION[s][t] == \"rj\") pop (the right hand of the production \"j:X-\u003ebeta\") state s = stack[top] push(X) push(Goto[s][X]) else error... ","date":"2021-01-27","objectID":"/compilerlr/:1:1","tags":["个人笔记"],"title":"【编译原理】简明自底向上分析算法总结：LR(0)，SLR，LR(1)，LALR分析算法","uri":"/compilerlr/"},{"categories":["个人笔记"],"content":"SLR分析 然而，LR(0)分析仍然可能存在冲突，考虑以下状态： E -\u003e T · T -\u003e T · * F 此时如果读入*，将无法得知应当采取移进动作还是采取归约动作（移进-归约冲突）。对于这种情况，SLR算法给出了一个依靠$FOLLOW$集解决的方案。对于下一个要读入的符号，它要么被移进，要么被归约成某个非终结符。设某状态下可接受若干符号，只要这些符号要么位于移进集合，要么位于某个FOLLOW集，集合之间两两互不相交，就可以用前看下一个输入的符号来解决。这种方法被称为简单的LR方法，也就是SLR方法。 SLR和LR的区别只在于对归约的处理： 对于状态i上的项目 X-\u003e ${\\alpha}$ · 仅对 y ${\\in}$FOLLOW(X)添加ACTION[i, y] ","date":"2021-01-27","objectID":"/compilerlr/:1:2","tags":["个人笔记"],"title":"【编译原理】简明自底向上分析算法总结：LR(0)，SLR，LR(1)，LALR分析算法","uri":"/compilerlr/"},{"categories":["个人笔记"],"content":"LR(1)分析 SLR分析仍然存在问题。SLR只是简单地考察下一个输入符号b是否属于与归约项目$A\\rightarrow\\alpha$相关联的$FOLLOW(A)$，但$b\\in FOLLOW(A)$只是归约$\\alpha$的一个必要条件，不是充分条件。LR(1)分析法提出的动机是，在特定位置，某符号$A$的后继符集合是$FOLLOW(A)$的子集。那么如何求出这个在特定位置的后继符集合呢？依靠前面已知状态的推导。观察如下例子： S -\u003e L = R L -\u003e * R 由第一条产生式可以进一步推导出 L -\u003e * R也应该加入到这个闭包里，但这两个L -\u003e * R是不一样的。原本的表达式是一个原始的式子，它期望后接的符号是终结符$，而由S推导出来的L式，后接的应该是=。因此推导出来的新闭包可以表示为： S -\u003e L = R, $ L -\u003e * R, = L -\u003e * R, $ 根据这样的思路，我们就把LR算法的前看1符号情况进行了细化，称为LR(1)算法。LR(1)的算法大部分和LR(0)相同，仅闭包的构造方法不同： 对项目$[X\\rightarrow\\alpha·Y\\beta,a]$ 添加$[Y\\rightarrow\\gamma,b]$到项目集 其中$b$是$X$式中$Y$被期望紧接着的符号（展望符）。 ","date":"2021-01-27","objectID":"/compilerlr/:1:3","tags":["个人笔记"],"title":"【编译原理】简明自底向上分析算法总结：LR(0)，SLR，LR(1)，LALR分析算法","uri":"/compilerlr/"},{"categories":["个人笔记"],"content":"LALR分析 LR(1)分析固然分析能力更强，但是也带来了新的问题：状态机中的许多状态，可能仅仅式被期望的后接符号（称为展望符）不一样，而他们的表达式集是完全相同的。LALR分析，即在LR(1)分析得到的状态机图基础上，将表达式完全相同的状态予以合并。这样合并以后，由于忽略了展望符的信息，可能产生归约-归约冲突。 LALR分析形式上与LR(1)相同，大小上与LR(0)/SLR相当，分析能力介于SLR和LR(1)之间。 分析能力：SLR(1)\u003cLALR(1)\u003cLR(1) 参考资料： 《编译原理》课程，陈鄞，哈尔滨工业大学（中国大学MOOC） 《编译原理》课程，华保健，中国科学院大学（网易云课堂或b站免费观看） 《编译原理》（紫龙书），机械工业出版社 《编译原理》，清华大学出版社 ","date":"2021-01-27","objectID":"/compilerlr/:1:4","tags":["个人笔记"],"title":"【编译原理】简明自底向上分析算法总结：LR(0)，SLR，LR(1)，LALR分析算法","uri":"/compilerlr/"},{"categories":["个人笔记"],"content":"语法分析概念 从编译器前端的流程上说，语法分析对词法分析得到的记号流进行分析，识别其中的语法错误，并将正确的记号流转化为语法树，交给编译器的后续步骤进行进一步处理。 ","date":"2021-01-27","objectID":"/compilerll/:0:0","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"上下文无关语法 上下文无关语法是一个四元组：$G=(T,N,P,S)$，其中 $T$是终结符集合 $N$是非终结符集合 $P$是一组产生式规则： 形式：$X\\rightarrow \\beta _1,\\beta _2,…,\\beta _n$ 其中$X\\in N,\\beta _i\\in (T\\cup N)$ $S$是唯一的开始符号，$S\\in N$ ","date":"2021-01-27","objectID":"/compilerll/:1:0","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"推导 给定文法$G$，从$S$开始，用产生式的右部替换左部的非终结符（把非终结符“展开”），直到不出现非终结符为止。推导结果称为句子。 最左推导：每次总选择最左侧符号替换 最右推导：每次总选择最右侧符号替换 语法分析的任务：给定$G$和句子$s$，回答是否存在对句子$s$的推导 ","date":"2021-01-27","objectID":"/compilerll/:2:0","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"分析树和二义性文法 ","date":"2021-01-27","objectID":"/compilerll/:3:0","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"分析树 推导可以表示成树状结构，树中的每个内部结点代表非终结符，每个叶子结点代表终结符，每一步推导代表如何从双亲结点生成直接孩子结点。 分析树的含义取决于树的后序遍历。 ","date":"2021-01-27","objectID":"/compilerll/:3:1","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"二义性文法 给定文法$G$，如果存在句子$s$对应不止一颗分析树，称$G$是二义性文法。 解决方案：文法重写 语法分析算法 显然，语法分析从两个思路去做： 思路1：根据文法$G$，从唯一的开始符号$S$开始，对非终结符，用产生式的右部替换左部（“展开”），观察是否能产生对应的句子$s$； 思路2：根据句子$s$，对其不断归约（“合并”），看是否能归约成开始符号$S$的形态。 思路1称为自顶向下分析，对应分析树的自顶向下的构造顺序；思路2称为自底向上分析。 ","date":"2021-01-27","objectID":"/compilerll/:3:2","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"自顶向下分析 从开始符号$S$出发去推导句子称为自顶向下分析。后文将从最原始的回溯展开动机出发，逐步讨论如何优化算法（然后更加秃头）。 ","date":"2021-01-27","objectID":"/compilerll/:4:0","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"朴素的回溯思路 最朴素的自顶向下分析思想是：从开始符号$S$出发，随意地推导出句子$t$，比较$t$和$s$。 以下是华保健老师里的网课伪代码： tokens[]; // holding all tokens i = 0; // 指向第i个token stack = [S] // S是开始符号 while (stack != []) if (stack[top] is a terminal t) if (t == tokens[i++]) // 如果匹配成功 pop(); else backtrack(); else if (stack[top] is a nonterminal T) pop(); push(the next right hand side of T) // 不符合，尝试下一个右部式 简单地说，就是不断地去试探展开式如何匹配每个句子，如果匹配不成功就回溯，试探下一种可能，由此引出递归下降分析算法和LL(1)分析算法。 ","date":"2021-01-27","objectID":"/compilerll/:4:1","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"递归下降分析算法 递归下降分析算法（需要回溯的方法）的基本思想如下： 每个非终结符构造一个分析函数 用前看符号指导产生式规则的选择 示例，对如下产生式规则： S -\u003e N V N N -\u003e s | t | g | w V -\u003e e | d 构造每条规则的算法伪代码： parse_S() parse(N) parse(V) parse(N) parse_N() token = token[i++] if (token == s || token == t || token == g || token == w) return; error(\"...\") parse_V() // TODO 一般的递归下降分析算法框架如下： parse_X() token = nextToken() switch(token) case ...: case ...: ...... 可以看出，通用的递归下降分析技术仍然可能需要回溯。据此进一步讨论LL(1)分析算法。 ","date":"2021-01-27","objectID":"/compilerll/:4:2","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"},{"categories":["个人笔记"],"content":"LL(1)分析 概念：从左(L)到右推导符号，最左(L)推导，采用一个(1)前看符号 基本思想：表驱动的分析方法 仍然是很直观的思路。对于需要回溯的情况，我们可以根据已有的条件和规律对其剪枝，从而避免无谓的搜索。而在语法分析当中，显然token与token之间的相对位置是存在关系的。据此，我们可以利用这些相对位置关系去构造分析表，记录遇到下一个符号时应该跳转到哪个状态，从而避免回溯。 具体地说，我们需要构造两个集合：$FIRST$集和$FOLLOW$集。$FIRST$集的动机是引导表达式展开的跳转方向，$FOLLOW$集的动机是避免空符$\\epsilon$带来的错误。当$FIRST$可能为空时，就应当加入$FOLLOW$集，后文算法将会体现这一点。 注：此处约定英文大写符号默认为非终结符，英文小写符号默认为终结符，希腊字母暗示为一般文法符号，无法确认是终结符还是非终结符。 $FIRST(\\alpha)$：从任意文法符号串$\\alpha$开始推导得出的所有可能的终结符集合。通俗地说，就是$\\alpha$可能以什么开头。 $FOLLOW(A)$：可能在某些句型中紧跟$A$后边的终结符号的集合。 对$FIRST$集可以采用不动点算法计算。计算各文法符号的$FIRST(\\alpha)$时，不断应用下列规则刷表，直到所有FIRST()都不再更新： 如果$\\alpha=a$是终结符，则$FIRST(a)={a}$； 如果$\\alpha=N$不是终结符，则对$N$的每个产生式$\\beta_1\\beta_2…\\beta_n$，对其中的$\\beta_i$，若$\\beta_1\\beta_2…\\beta_{i-1}$的$FIRST$集中都有$\\epsilon$空符，则$FIRST(N) \\cup = FIRST(\\beta_i)$。通俗地说，对于产生式的第$i$个符号，如果它前面的符号都可能取空，那么它的$FIRST$元素当然也可能是$N$的$FIRST$元素，因此要将它的集合加入到$N$的集合中去。当然，对于$i=1$的情况，总是会$FIRST(N)\\cup FIRST(\\beta_1)$。 给出伪代码如下： while (some set is changing) for (symbol alpha: symbols) if (alpha is terminal) FIRST[alpha] = {alpha} else if (alpha is nonterminal) for (production p: alpha-\u003ebeta_1,...beta_n) for (i = 1; i \u003c= n; i++) if (beta_i is terminal a) FIRST[alpha] += {a} break else if (beta_i is nonterminal M) FIRST[N] += FIRST[M] if (M cannot be null) break 类似地，可以给出$FOLLOW$集的不动点算法： 对所有非终结符$A$的FOLLOW(A)集合时，不断应用以下规则刷表，不再有集合被更新： 3. 如果存在产生式$A\\rightarrow \\alpha B\\beta$，则$\\beta$除空符$\\epsilon$以外的所有符号都在$FOLLOW(B)$中； 4. 如果存在产生式$A\\rightarrow \\alpha B$，或$A\\rightarrow \\alpha B\\beta$且$FIRST(\\beta)$包含空符$\\epsilon$，则$FOLLOW(B) \\cup=FOLLOW(A)$。 通俗地说，就是找到每个“紧跟其后”的终结符号。类比$FIRST$集的求法，把“紧跟其后”的符号的FIRST集加入所求的FOLLOW集中。如果“紧跟其后”的$FIRST$集有机会取空符，那么下一个集合的$FIRST$集合也有机会补上来“紧跟其后”，以此类推。 伪代码如下： while (some set is changing) for (nonterminal A : nonterminals) for (production p: A-\u003ebeta_1,...,beta_n) tmp = FOLLOW[N] for (i = n; i \u003e 0; i--) if (beta_i == terminal a) tmp = {a} else if (beta_i == nonterminal M) FOLLOW[M] += tmp if (M cannot be null) tmp = FIRST[M] else tmp += FIRST[M] 已有$FIRST集$，$FOLLOW$集，可按如下规则构造二维预测分析表$M[][]$，该预测分析表的行头是非终结符号，列头是输入的下一个符号（终结符号）。对文法$G$的每个产生式$A\\rightarrow\\alpha$，进行如下处理： 对于$FIRST(\\alpha)$的每个终结符号$\\alpha$，将$A\\rightarrow\\alpha$加入到$M[A,a]$中 如果$\\epsilon\\in FIRST(\\alpha)$，则对于$FOLLOW(A)$的每个终结符号$b$，也将$A\\rightarrow\\alpha$加入到$M[A,b]$中。 由上可以很清楚地看出$FOLLOW$集的作用：前一个$FIRST$为空的时候的“替补”。通过同时求解$FIRST$集和$FOLLOW$集，可以保证LL(1)分析总能前看到“正确”的符号。 由上，可以书写LL(1)分析伪代码： tokens[]; // all tokens i = 0; stack = [S] // S是开始符号 while (stack != []) if (stack[top] is a terminal t) if (t == token[i++]) pop(); else error(...); // 朴素自顶向下的回溯改成直接报错 else if (stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]); // 朴素自顶向下的尝试展开任意表达式改成按表展开 尽管LL(1)对朴素自顶向下做了优化，但LL(1)在语法上仍然存在发生冲突的可能。下面简单讨论两种解决冲突的方法：消除左递归和提取左公因子。 消除左递归 有例子如下： E -\u003e E + T | T 此时由于LL算法总是从左到右读入，从左到右展开，那么计算的时候将会无限展开E-\u003eE+T而进入死循环。对于左递归的情况，有一般解法可以转换成右递归，如上式可改写如下： E -\u003e T E' E'-\u003e + T E' 提取左公因子 有例子如下： X -\u003e a Y | a Z 显然，此时同样的a可能会导向不同的表达式，存在冲突，直观的解决方法时将公共的a提取出来，如下所示： X -\u003e a X' X'-\u003e Y | Z 先整理自顶向下到这里，有空再整理自底向上…… 参考资料： 《编译原理》课程，华保健，中国科学院大学（网易云课堂或b站免费观看） 《编译原理》（紫龙书），机械工业出版社 《编译原理》，清华大学出版社 ","date":"2021-01-27","objectID":"/compilerll/:4:3","tags":["个人笔记"],"title":"【编译原理】简明自顶向下分析算法总结：递归下降，LL(1)分析算法","uri":"/compilerll/"}]